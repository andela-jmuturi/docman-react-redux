import Axios from 'axios';
import AxiosMockAdapter from 'axios-mock-adapter';
import { fromJS } from 'immutable';
import { expect } from 'chai';

import thunk from 'redux-thunk';
import configureMockStore from 'redux-mock-store';

import * as rolesActions from '../../../client/src/actions/RolesActions';
import * as actionTypes from '../../../client/src/constants';

const TOKEN = 'fake.test.token';

// Setup mocks for testing async actions.
const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);
const mockAxios = new AxiosMockAdapter(Axios);

describe('RolesActions', () => {
  it('create an action when starting fetch roles request', () => {
    const expectedAction = {
      type: actionTypes.FETCH_ROLES_REQUEST
    };

    expect(rolesActions.fetchRolesRequest()).to.eql(expectedAction);
  });

  it('create an action on successful roles fetch', () => {
    const roles = [{
      admin: 'admin',
      private: 'private'
    }];

    const expectedAction = {
      type: actionTypes.FETCH_ROLES_SUCCESS,
      roles
    };

    expect(rolesActions.fetchRolesSuccess({ data: roles }))
      .to.eql(expectedAction);
  });

  it('create FETCH_ROLES_FAILURE when a role fetch request fails', () => {
    const error = new Error('This is a test');
    const expectedAction = {
      type: actionTypes.FETCH_ROLES_FAILURE,
      error: { message: error.message }
    };

    expect(rolesActions.fetchRolesFailure(error))
      .to.eql(expectedAction);
  });

  it('FETCH_ROLES_FAILURE correctly handles errors returned by Axios', () => {
    const error = {
      data: {
        message: 'This is an error'
      }
    };
    const expectedAction = {
      type: actionTypes.FETCH_ROLES_FAILURE,
      error: error.data
    };

    expect(rolesActions.fetchRolesFailure(error))
      .to.eql(expectedAction);
  });

  describe('.fetchRoles()', () => {
    afterEach(() => {
      mockAxios.reset();
    });

    it('creates FETCH_ROLES_SUCCESS when fetching roles is done', () => {
      const roles = [{
        title: 'role1'
      }, {
        title: 'role2'
      }];

      const expectedActions = [
        { type: actionTypes.FETCH_ROLES_REQUEST },
        { type: actionTypes.FETCH_ROLES_SUCCESS, roles }
      ];

      const store = mockStore({ roles: [] });

      mockAxios
        .onGet('/api/roles')
        .reply(200, roles);

      return store.dispatch(rolesActions.fetchRoles(TOKEN))
        .then(() => {
          const actions = store.getActions();
          expect(actions).to.eql(expectedActions);
        });
    });

    it('creates FETCH_ROLES_FAILURE if failed to fetch roles', () => {
      const error = {
        message: 'Test failure'
      };
      mockAxios
        .onGet('/api/roles')
        .reply(400, error);

      const expectedActions = [{
        type: 'FETCH_ROLES_REQUEST'
      }, {
        type: 'FETCH_DOCUMENTS_FAILURE',
        error: {
          message: 'Test failure'
        }
      }];

      const store = mockStore();
      return store.dispatch(rolesActions.fetchRoles(TOKEN))
        .then(() => {
          const actions = store.getActions();
          expect(actions).to.eql(expectedActions);
        });
    });
  });

  describe('.fetchRolesIfNecessary()', () => {
    const roles = [{
      title: 'role1'
    }, {
      title: 'role2'
    }];

    // This might seem like weird state shape, but it's necessary since
    // this is the state shape generated by `combineReducers`.
    // `getState` will return the state in the store.
    const getState = () => fromJS({
      roles: {
        roles
      }
    });

    it("doesn't hit the API if there are roles already in the state", () => {
      const expectedActions = {
        type: actionTypes.FETCH_ROLES_SUCCESS,
        roles
      };

      // Notice we're not even mocking Axios
      const store = mockStore(getState);
      const actions = store
        .dispatch(rolesActions.fetchRolesIfNecessary(TOKEN));

      expect(actions).to.eql(expectedActions);
    });

    it('hits the API if forced (force === true)', () => {
      mockAxios
        .onGet('/api/roles')
        .reply(200, roles);

      const expectedActions = [
        { type: actionTypes.FETCH_ROLES_REQUEST },
        { type: actionTypes.FETCH_ROLES_SUCCESS, roles }
      ];
      // Notice we're not even mocking Axios
      const store = mockStore(getState);
      return store.dispatch(rolesActions.fetchRolesIfNecessary(TOKEN, true))
        .then(() => {
          const actions = store.getActions();
          expect(actions).to.eql(expectedActions);
        });
    });
  });
});
